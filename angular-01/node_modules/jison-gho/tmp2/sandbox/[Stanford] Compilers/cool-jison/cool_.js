/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var cool = function() {
    var o = function(k, v, o, l) {
        for (o = o || {}, l = k.length; l--; o[k[l]] = v) ;
        return o;
    }, $V0 = [ 1, 5 ], $V1 = [ 1, 7 ], $V2 = [ 11, 14 ], $V3 = [ 2, 7 ], $V4 = [ 1, 14 ], $V5 = [ 1, 18 ], $V6 = [ 17, 23 ], $V7 = [ 1, 28 ], $V8 = [ 1, 42 ], $V9 = [ 1, 39 ], $Va = [ 1, 49 ], $Vb = [ 1, 40 ], $Vc = [ 1, 41 ], $Vd = [ 1, 43 ], $Ve = [ 1, 44 ], $Vf = [ 1, 45 ], $Vg = [ 1, 46 ], $Vh = [ 1, 47 ], $Vi = [ 1, 48 ], $Vj = [ 1, 50 ], $Vk = [ 1, 51 ], $Vl = [ 1, 52 ], $Vm = [ 1, 54 ], $Vn = [ 1, 55 ], $Vo = [ 1, 56 ], $Vp = [ 1, 57 ], $Vq = [ 1, 58 ], $Vr = [ 1, 59 ], $Vs = [ 1, 60 ], $Vt = [ 1, 61 ], $Vu = [ 1, 62 ], $Vv = [ 6, 11, 17, 23, 30, 31, 33, 34, 35, 37, 38, 42, 46, 47, 48, 49, 51, 52, 53, 58 ], $Vw = [ 1, 72 ], $Vx = [ 1, 71 ], $Vy = [ 2, 18 ], $Vz = [ 6, 11, 17, 23, 33, 34, 35, 37, 38, 42, 46, 47, 48, 49, 51, 52, 53, 58 ], $VA = [ 6, 11, 17, 23, 33, 34, 35, 37, 38, 42, 58 ], $VB = [ 6, 11, 17, 23, 33, 34, 35, 37, 38, 42, 46, 47, 51, 52, 53, 58 ], $VC = [ 1, 107 ], $VD = [ 2, 9, 11, 14, 15, 32, 36, 39, 41, 44, 45, 50, 54, 55, 56, 57 ], $VE = [ 1, 115 ], $VF = [ 14, 43 ];
    var parser = {
        trace: function trace() {
            Jison.print.apply(null, arguments);
        },
        yy: {},
        symbols_: {
            error: 2,
            program: 3,
            class_list: 4,
            class: 5,
            ";": 6,
            CLASS: 7,
            TYPEID: 8,
            "{": 9,
            feature_list: 10,
            "}": 11,
            INHERITS: 12,
            feature: 13,
            OBJECTID: 14,
            "(": 15,
            formals: 16,
            ")": 17,
            ":": 18,
            expression: 19,
            ASSIGN: 20,
            formals_nonempty: 21,
            formal: 22,
            ",": 23,
            expressions: 24,
            expressions_nonempty: 25,
            expressions_semicolon: 26,
            cases: 27,
            case: 28,
            DARROW: 29,
            "@": 30,
            ".": 31,
            IF: 32,
            THEN: 33,
            ELSE: 34,
            FI: 35,
            WHILE: 36,
            LOOP: 37,
            POOL: 38,
            LET: 39,
            nested_let: 40,
            CASE: 41,
            OF: 42,
            ESAC: 43,
            NEW: 44,
            ISVOID: 45,
            "+": 46,
            "-": 47,
            "*": 48,
            "/": 49,
            "~": 50,
            "<": 51,
            LE: 52,
            "=": 53,
            NOT: 54,
            INT_CONST: 55,
            BOOL_CONST: 56,
            STR_CONST: 57,
            IN: 58,
            $accept: 0,
            $end: 1
        },
        terminals_: {
            2: "error",
            6: ";",
            7: "CLASS",
            8: "TYPEID",
            9: "{",
            11: "}",
            12: "INHERITS",
            14: "OBJECTID",
            15: "(",
            17: ")",
            18: ":",
            20: "ASSIGN",
            23: ",",
            29: "DARROW",
            30: "@",
            31: ".",
            32: "IF",
            33: "THEN",
            34: "ELSE",
            35: "FI",
            36: "WHILE",
            37: "LOOP",
            38: "POOL",
            39: "LET",
            41: "CASE",
            42: "OF",
            43: "ESAC",
            44: "NEW",
            45: "ISVOID",
            46: "+",
            47: "-",
            48: "*",
            49: "/",
            50: "~",
            51: "<",
            52: "LE",
            53: "=",
            54: "NOT",
            55: "INT_CONST",
            56: "BOOL_CONST",
            57: "STR_CONST",
            58: "IN"
        },
        productions_: [ 0, [ 3, 1 ], [ 4, 2 ], [ 4, 3 ], [ 4, 2 ], [ 5, 5 ], [ 5, 7 ], [ 10, 0 ], [ 10, 3 ], [ 10, 2 ], [ 13, 9 ], [ 13, 5 ], [ 13, 3 ], [ 16, 0 ], [ 16, 1 ], [ 21, 1 ], [ 21, 3 ], [ 22, 3 ], [ 24, 0 ], [ 24, 1 ], [ 25, 1 ], [ 25, 3 ], [ 26, 2 ], [ 26, 3 ], [ 26, 3 ], [ 27, 1 ], [ 27, 2 ], [ 28, 6 ], [ 19, 3 ], [ 19, 8 ], [ 19, 6 ], [ 19, 4 ], [ 19, 7 ], [ 19, 5 ], [ 19, 3 ], [ 19, 3 ], [ 19, 2 ], [ 19, 5 ], [ 19, 2 ], [ 19, 2 ], [ 19, 3 ], [ 19, 3 ], [ 19, 3 ], [ 19, 3 ], [ 19, 2 ], [ 19, 3 ], [ 19, 3 ], [ 19, 3 ], [ 19, 2 ], [ 19, 3 ], [ 19, 1 ], [ 19, 1 ], [ 19, 1 ], [ 19, 1 ], [ 40, 7 ], [ 40, 5 ], [ 40, 7 ], [ 40, 5 ], [ 40, 1 ] ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            /* this == yyval */
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                this.$ = [ "PROGRAM", {}, $$[$0] ];
                typeof console !== "undefined" ? console.log($$[$0]) : print($$[$0]);
                return this.$;
                break;

              case 2:
                this.$ = [ "CLASS_LIST", {}, $$[$0 - 1] ];
                break;

              case 3:
                this.$ = appendChild($$[$0 - 2], $$[$0 - 1]);
                parse_results = this.$;
                break;

              case 5:
                this.$ = [ "CLASS", {}, $$[$0 - 3], "Object", $$[$0 - 1] ];
                break;

              case 6:
                this.$ = [ "CLASS", {}, $$[$0 - 5], $$[$0 - 3], $$[$0 - 1] ];
                break;

              case 7:
                this.$ = [ "FEATURES", {} ];
                break;

              case 8:
              case 23:
                this.$ = appendChild($$[$0 - 2], $$[$0 - 1]);
                break;

              case 9:
              case 24:
              case 35:
                break;

              case 10:
                this.$ = [ "METHOD", {}, $$[$0 - 8], $$[$0 - 6], $$[$0 - 3], $$[$0 - 1] ];
                break;

              case 11:
                this.$ = [ "ATTR", {}, $$[$0 - 4], $$[$0 - 2], $$[$0] ];
                break;

              case 12:
                this.$ = [ "ATTR", {}, $$[$0 - 2], $$[$0], no_expr() ];
                break;

              case 13:
                this.$ = [ "FORMALS", {} ];
                break;

              case 14:
              case 19:
                this.$ = $$[$0];
                break;

              case 15:
                this.$ = [ "FORMALS", {}, $$[$0] ];
                break;

              case 16:
              case 21:
                this.$ = appendChild($$[$0 - 2], $$[$0]);
                break;

              case 17:
                this.$ = [ "FORMAL", {}, $$[$0 - 2], $$[$0] ];
                break;

              case 18:
                this.$ = [ "EXPRESSIONS", {} ];
                break;

              case 20:
                this.$ = [ "EXPRESSIONS", {}, $$[$0] ];
                break;

              case 22:
                this.$ = [ "EXPRESSIONS", {}, $$[$0 - 1] ];
                break;

              case 25:
                this.$ = [ "CASES", {}, $$[$0] ];
                break;

              case 26:
                this.$ = appendChild($$[$0 - 1], $$[$0]);
                break;

              case 27:
                this.$ = [ "BRANCH", {}, $$[$0 - 5], $$[$0 - 3], $$[$0 - 1] ];
                break;

              case 28:
                this.$ = [ "ASSIGN", {}, $$[$0 - 2], $$[$0] ];
                break;

              case 29:
                this.$ = [ "STATIC_DISPATCH", {}, $$[$0 - 7], $$[$0 - 5], $$[$0 - 3], $$[$0 - 1] ];
                break;

              case 30:
                this.$ = [ "DISPATCH", {}, $$[$0 - 5], $$[$0 - 3], $$[$0 - 1] ];
                break;

              case 31:
                this.$ = [ "DISPATCH", {}, "self", $$[$0 - 3], $$[$0 - 1] ];
                break;

              case 32:
                this.$ = [ "COND", {}, $$[$0 - 5], $$[$0 - 3], $$[$0 - 1] ];
                break;

              case 33:
                this.$ = [ "LOOP", {}, $$[$0 - 3], $$[$0 - 1] ];
                break;

              case 34:
                this.$ = [ "BLOCK", {}, $$[$0 - 1] ];
                break;

              case 36:
                this.$ = [ "NESTED_LET", {}, $$[$0] ];
                break;

              case 37:
                this.$ = [ "TYPCASE", {}, $$[$0 - 3], $$[$0 - 1] ];
                break;

              case 38:
                this.$ = [ "NEW", {}, $$[$0] ];
                break;

              case 39:
                this.$ = [ "ISVOID", {}, $$[$0] ];
                break;

              case 40:
                this.$ = [ "PLUS", {}, $$[$0 - 2], $$[$0] ];
                break;

              case 41:
                this.$ = [ "SUB", {}, $$[$0 - 2], $$[$0] ];
                break;

              case 42:
                this.$ = [ "MUL", {}, $$[$0 - 2], $$[$0] ];
                break;

              case 43:
                this.$ = [ "DIVIDE", {}, $$[$0 - 2], $$[$0] ];
                break;

              case 44:
                this.$ = [ "NEG", {}, $$[$0] ];
                break;

              case 45:
                this.$ = [ "LT", {}, $$[$0 - 2], $$[$0] ];
                break;

              case 46:
                this.$ = [ "LEQ", {}, $$[$0 - 2], $$[$0] ];
                break;

              case 47:
                this.$ = [ "EQ", {}, $$[$0 - 2], $$[$0] ];
                break;

              case 48:
                this.$ = [ "NOT", {}, $$[$0] ];
                break;

              case 49:
                this.$ = [ "PAREN", {}, $$[$0 - 2] ];
                break;

              case 50:
                this.$ = [ "INT_CONST", {
                    val: parseInt(yytext)
                } ];
                break;

              case 51:
                this.$ = [ "BOOL_CONST", {
                    val: JSON.parse(yytext)
                } ];
                break;

              case 52:
                this.$ = [ "STR_CONST", {
                    val: yytext
                } ];
                break;

              case 53:
                this.$ = [ "OBJECTID", {
                    val: yytext
                } ];
                break;

              case 54:
              case 56:
                this.$ = [ "LET", {}, $$[$0 - 6], $$[$0 - 4], $$[$0 - 2], $$[$0] ];
                break;

              case 55:
              case 57:
                this.$ = [ "LET", {}, $$[$0 - 4], $$[$0 - 2], no_expr(), $$[$0] ];
                break;

              case 58:
                break;
            }
        },
        table: [ {
            2: [ 1, 4 ],
            3: 1,
            4: 2,
            5: 3,
            7: $V0
        }, {
            1: [ 3 ]
        }, {
            1: [ 2, 1 ],
            5: 6,
            7: $V0
        }, {
            6: $V1
        }, {
            6: [ 1, 8 ]
        }, {
            8: [ 1, 9 ]
        }, {
            6: [ 1, 10 ]
        }, o($V1, [ 2, 2 ]), o($V1, [ 2, 4 ]), {
            9: [ 1, 11 ],
            12: [ 1, 12 ]
        }, o($V1, [ 2, 3 ]), o($V2, $V3, {
            10: 13,
            2: $V4
        }), {
            8: [ 1, 15 ]
        }, {
            11: [ 1, 16 ],
            13: 17,
            14: $V5
        }, {
            6: [ 1, 19 ]
        }, {
            9: [ 1, 20 ]
        }, {
            6: [ 2, 5 ]
        }, {
            6: [ 1, 21 ]
        }, {
            15: [ 1, 22 ],
            18: [ 1, 23 ]
        }, o($V2, [ 2, 9 ]), o($V2, $V3, {
            10: 24,
            2: $V4
        }), o($V2, [ 2, 8 ]), o($V6, [ 2, 13 ], {
            16: 25,
            21: 26,
            22: 27,
            14: $V7
        }), {
            8: [ 1, 29 ]
        }, {
            11: [ 1, 30 ],
            13: 17,
            14: $V5
        }, {
            17: [ 1, 31 ],
            23: [ 1, 32 ]
        }, o($V6, [ 2, 14 ]), o($V6, [ 2, 15 ]), {
            18: [ 1, 33 ]
        }, {
            6: [ 2, 12 ],
            20: [ 1, 34 ]
        }, {
            6: [ 2, 6 ]
        }, {
            18: [ 1, 35 ]
        }, {
            14: $V7,
            22: 36
        }, {
            8: [ 1, 37 ]
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 38,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            8: [ 1, 53 ]
        }, o($V6, [ 2, 16 ]), o($V6, [ 2, 17 ]), {
            6: [ 2, 11 ],
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, o($Vv, [ 2, 53 ], {
            15: [ 1, 64 ],
            20: [ 1, 63 ]
        }), {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 65,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 66,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            2: [ 1, 68 ],
            9: $V8,
            14: $V9,
            15: $Va,
            19: 69,
            26: 67,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            2: $Vw,
            14: $Vx,
            40: 70
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 73,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            8: [ 1, 74 ]
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 75,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 76,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 77,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 78,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, o($Vv, [ 2, 50 ]), o($Vv, [ 2, 51 ]), o($Vv, [ 2, 52 ]), {
            9: [ 1, 79 ]
        }, {
            8: [ 1, 80 ]
        }, {
            14: [ 1, 81 ]
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 82,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 83,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 84,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 85,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 86,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 87,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 88,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 89,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, o($V6, $Vy, {
            24: 90,
            25: 91,
            19: 92,
            9: $V8,
            14: $V9,
            15: $Va,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }), {
            30: $Vm,
            31: $Vn,
            33: [ 1, 93 ],
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, {
            30: $Vm,
            31: $Vn,
            37: [ 1, 94 ],
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, {
            2: [ 1, 97 ],
            9: $V8,
            11: [ 1, 95 ],
            14: $V9,
            15: $Va,
            19: 96,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            11: [ 1, 98 ]
        }, {
            6: [ 1, 99 ],
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, o($Vv, [ 2, 36 ]), {
            18: [ 1, 100 ]
        }, o($Vv, [ 2, 58 ]), {
            30: $Vm,
            31: $Vn,
            42: [ 1, 101 ],
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, o($Vv, [ 2, 38 ]), o($Vz, [ 2, 39 ], {
            30: $Vm,
            31: $Vn
        }), o($Vz, [ 2, 44 ], {
            30: $Vm,
            31: $Vn
        }), o($VA, [ 2, 48 ], {
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }), {
            17: [ 1, 102 ],
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 103,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            31: [ 1, 104 ]
        }, {
            15: [ 1, 105 ]
        }, o($VB, [ 2, 40 ], {
            30: $Vm,
            31: $Vn,
            48: $Vq,
            49: $Vr
        }), o($VB, [ 2, 41 ], {
            30: $Vm,
            31: $Vn,
            48: $Vq,
            49: $Vr
        }), o($Vz, [ 2, 42 ], {
            30: $Vm,
            31: $Vn
        }), o($Vz, [ 2, 43 ], {
            30: $Vm,
            31: $Vn
        }), o($VA, [ 2, 45 ], {
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr
        }), o($VA, [ 2, 46 ], {
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr
        }), o($VA, [ 2, 47 ], {
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr
        }), o($VA, [ 2, 28 ], {
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }), {
            17: [ 1, 106 ],
            23: $VC
        }, o($V6, [ 2, 19 ]), o($V6, [ 2, 20 ], {
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }), {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 108,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 109,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, o($Vv, [ 2, 34 ]), {
            6: [ 1, 110 ],
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, {
            6: [ 1, 111 ]
        }, o($Vv, [ 2, 35 ]), o($VD, [ 2, 22 ]), {
            8: [ 1, 112 ]
        }, {
            14: $VE,
            27: 113,
            28: 114
        }, o($Vv, [ 2, 49 ]), {
            11: [ 1, 116 ],
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, {
            14: [ 1, 117 ]
        }, o($V6, $Vy, {
            25: 91,
            19: 92,
            24: 118,
            9: $V8,
            14: $V9,
            15: $Va,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }), o($Vv, [ 2, 31 ]), {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 119,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            30: $Vm,
            31: $Vn,
            34: [ 1, 120 ],
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, {
            30: $Vm,
            31: $Vn,
            38: [ 1, 121 ],
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, o($VD, [ 2, 23 ]), o($VD, [ 2, 24 ]), {
            20: [ 1, 122 ],
            23: [ 1, 124 ],
            58: [ 1, 123 ]
        }, {
            14: $VE,
            28: 126,
            43: [ 1, 125 ]
        }, o($VF, [ 2, 25 ]), {
            18: [ 1, 127 ]
        }, {
            6: [ 2, 10 ]
        }, {
            15: [ 1, 128 ]
        }, {
            17: [ 1, 129 ],
            23: $VC
        }, o($V6, [ 2, 21 ], {
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }), {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 130,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, o($Vv, [ 2, 33 ]), {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 131,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 132,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            2: $Vw,
            14: $Vx,
            40: 133
        }, o($Vv, [ 2, 37 ]), o($VF, [ 2, 26 ]), {
            8: [ 1, 134 ]
        }, o($V6, $Vy, {
            25: 91,
            19: 92,
            24: 135,
            9: $V8,
            14: $V9,
            15: $Va,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }), o($Vv, [ 2, 30 ]), {
            30: $Vm,
            31: $Vn,
            35: [ 1, 136 ],
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, {
            23: [ 1, 138 ],
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu,
            58: [ 1, 137 ]
        }, o($VA, [ 2, 55 ], {
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }), o($Vv, [ 2, 57 ]), {
            29: [ 1, 139 ]
        }, {
            17: [ 1, 140 ],
            23: $VC
        }, o($Vv, [ 2, 32 ]), {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 141,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, {
            2: $Vw,
            14: $Vx,
            40: 142
        }, {
            9: $V8,
            14: $V9,
            15: $Va,
            19: 143,
            32: $Vb,
            36: $Vc,
            39: $Vd,
            41: $Ve,
            44: $Vf,
            45: $Vg,
            50: $Vh,
            54: $Vi,
            55: $Vj,
            56: $Vk,
            57: $Vl
        }, o($Vv, [ 2, 29 ]), o($VA, [ 2, 54 ], {
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }), o($Vv, [ 2, 56 ]), {
            6: [ 1, 144 ],
            30: $Vm,
            31: $Vn,
            46: $Vo,
            47: $Vp,
            48: $Vq,
            49: $Vr,
            51: $Vs,
            52: $Vt,
            53: $Vu
        }, o($VF, [ 2, 27 ]) ],
        defaultActions: {
            16: [ 2, 5 ],
            30: [ 2, 6 ],
            116: [ 2, 10 ]
        },
        parseError: function parseError(str, hash) {
            if (hash.recoverable) {
                this.trace(str);
            } else {
                var error = new Error(str);
                error.hash = hash;
                throw error;
            }
        },
        parse: function parse(input) {
            var self = this, stack = [ 0 ], tstack = [], // token stack
            vstack = [ null ], // semantic value stack
            lstack = [], // location stack
            table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
            var args = lstack.slice.call(arguments, 1);
            //this.reductionCount = this.shiftCount = 0;
            var lexer = Object.create(this.lexer);
            var sharedState = {
                yy: {}
            };
            // copy state
            for (var k in this.yy) {
                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                    sharedState.yy[k] = this.yy[k];
                }
            }
            lexer.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer;
            sharedState.yy.parser = this;
            if (typeof lexer.yylloc == "undefined") {
                lexer.yylloc = {};
            }
            var yyloc = lexer.yylloc;
            lstack.push(yyloc);
            var ranges = lexer.options && lexer.options.ranges;
            if (typeof sharedState.yy.parseError === "function") {
                this.parseError = sharedState.yy.parseError;
            } else {
                this.parseError = Object.getPrototypeOf(this).parseError;
            }
            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }
            _token_stack: var lex = function() {
                var token;
                token = lexer.lex() || EOF;
                // if token isn't its numeric value, convert
                if (typeof token !== "number") {
                    token = self.symbols_[token] || token;
                }
                return token;
            };
            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
            while (true) {
                // retreive state number from top of stack
                state = stack[stack.length - 1];
                // use default actions if available
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == "undefined") {
                        symbol = lex();
                    }
                    // read action for current state and first input
                    action = table[state] && table[state][symbol];
                }
                _handle_error: // handle parse error
                if (typeof action === "undefined" || !action.length || !action[0]) {
                    var error_rule_depth;
                    var errStr = "";
                    // Return the rule stack depth where the nearest error rule can be found.
                    // Return FALSE when no error recovery rule was found.
                    function locateNearestErrorRecoveryRule(state) {
                        var stack_probe = stack.length - 1;
                        var depth = 0;
                        // try to recover from error
                        for (;;) {
                            // check for error recovery rule in this state
                            if (TERROR.toString() in table[state]) {
                                return depth;
                            }
                            if (state === 0 || stack_probe < 2) {
                                return false;
                            }
                            stack_probe -= 2;
                            // popStack(1): [symbol, action]
                            state = stack[stack_probe];
                            ++depth;
                        }
                    }
                    if (!recovering) {
                        // first see if there's any chance at hitting an error recovery rule:
                        error_rule_depth = locateNearestErrorRecoveryRule(state);
                        // Report error
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push("'" + this.terminals_[p] + "'");
                            }
                        }
                        if (lexer.showPosition) {
                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                        } else {
                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                        }
                        this.parseError(errStr, {
                            text: lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: lexer.yylineno,
                            loc: yyloc,
                            expected: expected,
                            recoverable: error_rule_depth !== false
                        });
                    } else if (preErrorSymbol !== EOF) {
                        error_rule_depth = locateNearestErrorRecoveryRule(state);
                    }
                    // just recovered from another error
                    if (recovering == 3) {
                        if (symbol === EOF || preErrorSymbol === EOF) {
                            throw new Error(errStr || "Parsing halted while starting to recover from another error.");
                        }
                        // discard current lookahead and grab another
                        yyleng = lexer.yyleng;
                        yytext = lexer.yytext;
                        yylineno = lexer.yylineno;
                        yyloc = lexer.yylloc;
                        symbol = lex();
                    }
                    // try to recover from error
                    if (error_rule_depth === false) {
                        throw new Error(errStr || "Parsing halted. No suitable error recovery rule available.");
                    }
                    popStack(error_rule_depth);
                    preErrorSymbol = symbol == TERROR ? null : symbol;
                    // save the lookahead token
                    symbol = TERROR;
                    // insert generic error symbol as new lookahead
                    state = stack[stack.length - 1];
                    action = table[state] && table[state][TERROR];
                    recovering = 3;
                }
                // this shouldn't happen, unless resolve defaults are off
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                }
                switch (action[0]) {
                  case 1:
                    // shift
                    //this.shiftCount++;
                    stack.push(symbol);
                    vstack.push(lexer.yytext);
                    lstack.push(lexer.yylloc);
                    stack.push(action[1]);
                    // push state
                    symbol = null;
                    if (!preErrorSymbol) {
                        // normal execution/no error
                        yyleng = lexer.yyleng;
                        yytext = lexer.yytext;
                        yylineno = lexer.yylineno;
                        yyloc = lexer.yylloc;
                        if (recovering > 0) {
                            recovering--;
                        }
                    } else {
                        // error just occurred, resume old lookahead f/ before error
                        symbol = preErrorSymbol;
                        preErrorSymbol = null;
                    }
                    break;

                  case 2:
                    // reduce
                    //this.reductionCount++;
                    len = this.productions_[action[1]][1];
                    // perform semantic action
                    yyval.$ = vstack[vstack.length - len];
                    // default to $$ = $1
                    // default location, uses first token for firsts, last for lasts
                    yyval._$ = {
                        first_line: lstack[lstack.length - (len || 1)].first_line,
                        last_line: lstack[lstack.length - 1].last_line,
                        first_column: lstack[lstack.length - (len || 1)].first_column,
                        last_column: lstack[lstack.length - 1].last_column
                    };
                    if (ranges) {
                        yyval._$.range = [ lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1] ];
                    }
                    r = this.performAction.apply(yyval, [ yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack ].concat(args));
                    if (typeof r !== "undefined") {
                        return r;
                    }
                    // pop off stack
                    if (len) {
                        stack = stack.slice(0, -1 * len * 2);
                        vstack = vstack.slice(0, -1 * len);
                        lstack = lstack.slice(0, -1 * len);
                    }
                    stack.push(this.productions_[action[1]][0]);
                    // push nonterminal (reduce)
                    vstack.push(yyval.$);
                    lstack.push(yyval._$);
                    // goto new state = table[STATE][NONTERMINAL]
                    newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                    stack.push(newState);
                    break;

                  case 3:
                    // accept
                    return true;
                }
            }
            return true;
        }
    };
    var Jison = require("jison");
    function prependChild(node, child) {
        node.splice(2, 0, child);
        return node;
    }
    function appendChild(node, child) {
        node.splice(node.length, 0, child);
        return node;
    }
    function no_expr() {
        return [ "EXPRESSION", {} ];
    }
    /* generated by jison-lex 0.3.4 */
    var lexer = function() {
        var lexer = {
            EOF: 1,
            parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },
            // resets the lexer, sets new input
            setInput: function(input, yy) {
                this.yy = yy || this.yy || {};
                this._input = input;
                this._more = this._backtrack = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = "";
                this.conditionStack = [ "INITIAL" ];
                this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                };
                if (this.options.ranges) {
                    this.yylloc.range = [ 0, 0 ];
                }
                this.offset = 0;
                return this;
            },
            // consumes and returns one char from the input
            input: function() {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) {
                    this.yylloc.range[1]++;
                }
                this._input = this._input.slice(1);
                return ch;
            },
            // unshifts one char (or a string) into the input
            unput: function(ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);
                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len);
                //this.yyleng -= len;
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);
                if (lines.length - 1) {
                    this.yylineno -= lines.length - 1;
                }
                var r = this.yylloc.range;
                this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };
                if (this.options.ranges) {
                    this.yylloc.range = [ r[0], r[0] + this.yyleng - len ];
                }
                this.yyleng = this.yytext.length;
                return this;
            },
            // When called from action, caches matched text and appends it on next action
            more: function() {
                this._more = true;
                return this;
            },
            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: function() {
                if (this.options.backtrack_lexer) {
                    this._backtrack = true;
                } else {
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
                return this;
            },
            // retain first n characters of the match
            less: function(n) {
                this.unput(this.match.slice(n));
            },
            // displays already matched input, i.e. for error messages
            pastInput: function() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            // displays upcoming input, i.e. for error messages
            upcomingInput: function() {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: function() {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },
            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: function(match, indexed_rule) {
                var token, lines, backup;
                if (this.options.backtrack_lexer) {
                    // save context
                    backup = {
                        yylineno: this.yylineno,
                        yylloc: {
                            first_line: this.yylloc.first_line,
                            last_line: this.last_line,
                            first_column: this.yylloc.first_column,
                            last_column: this.yylloc.last_column
                        },
                        yytext: this.yytext,
                        match: this.match,
                        matches: this.matches,
                        matched: this.matched,
                        yyleng: this.yyleng,
                        offset: this.offset,
                        _more: this._more,
                        _input: this._input,
                        yy: this.yy,
                        conditionStack: this.conditionStack.slice(0),
                        done: this.done
                    };
                    if (this.options.ranges) {
                        backup.yylloc.range = this.yylloc.range.slice(0);
                    }
                }
                lines = match[0].match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno += lines.length;
                }
                this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                };
                this.yytext += match[0];
                this.match += match[0];
                this.matches = match;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                    this.yylloc.range = [ this.offset, this.offset += this.yyleng ];
                }
                this._more = false;
                this._backtrack = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input) {
                    this.done = false;
                }
                if (token) {
                    return token;
                } else if (this._backtrack) {
                    // recover context
                    for (var k in backup) {
                        this[k] = backup[k];
                    }
                    return false;
                }
                return false;
            },
            // return next match in input
            next: function() {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) {
                    this.done = true;
                }
                var token, match, tempMatch, index;
                if (!this._more) {
                    this.yytext = "";
                    this.match = "";
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (this.options.backtrack_lexer) {
                            token = this.test_match(tempMatch, rules[i]);
                            if (token !== false) {
                                return token;
                            } else if (this._backtrack) {
                                match = false;
                                continue;
                            } else {
                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                                return false;
                            }
                        } else if (!this.options.flex) {
                            break;
                        }
                    }
                }
                if (match) {
                    token = this.test_match(match, rules[index]);
                    if (token !== false) {
                        return token;
                    }
                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                    return false;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    });
                }
            },
            // return next match that has a token
            lex: function lex() {
                var r = this.next();
                if (r) {
                    return r;
                } else {
                    return this.lex();
                }
            },
            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },
            // pop the previously active lexer condition state off the condition stack
            popState: function popState() {
                var n = this.conditionStack.length - 1;
                if (n > 0) {
                    return this.conditionStack.pop();
                } else {
                    return this.conditionStack[0];
                }
            },
            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: function _currentRules() {
                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                } else {
                    return this.conditions["INITIAL"].rules;
                }
            },
            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: function topState(n) {
                n = this.conditionStack.length - 1 - Math.abs(n || 0);
                if (n >= 0) {
                    return this.conditionStack[n];
                } else {
                    return "INITIAL";
                }
            },
            // alias for begin(condition)
            pushState: function pushState(condition) {
                this.begin(condition);
            },
            // return the number of states currently on the stack
            stateStackSize: function stateStackSize() {
                return this.conditionStack.length;
            },
            options: {
                flex: true
            },
            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                var nested_comment_count = 0, string_error = false, MAX_STR_CONST = 256, string_buf = "";
                yy.lval = undefined;
                yy.error_msg = undefined;
                yy.curr_lineno = 1;
                yy.lex_error = function() {
                    console.error("Lexer error at line " + yy.curr_lineno + ":\n" + this.showPosition() + "\n", yy.error_msg);
                };
                var YYSTATE = YY_START;
                switch ($avoiding_name_collisions) {
                  case 0:
                    return "DARROW";
                    break;

                  case 1:
                    return "LE";
                    break;

                  case 2:
                    return "ASSIGN";
                    break;

                  case 3:
                    return "INT_CONST";
                    break;

                  case 4:
                    return "BOOL_CONST";
                    break;

                  case 5:
                    return "BOOL_CONST";
                    break;

                  case 6:
                    yy.curr_lineno++;
                    break;

                  case 7:
                    this.pushState("LINE_COMMENT");
                    break;

                  case 8:
                    ;
                    break;

                  case 9:
                    yy.curr_lineno++;
                    this.popState();
                    break;

                  case 10:
                    this.popState();
                    // eof in this case is ok
                    break;

                  case 11:
                    yy.error_msg = "Unmatched *)";
                    yy.lex_error();
                    break;

                  case 12:
                    this.pushState("COMMENT");
                    break;

                  case 13:
                    nested_comment_count++;
                    break;

                  case 14:
                    if (nested_comment_count == 0) this.popState(); else nested_comment_count--;
                    break;

                  case 15:
                    ;
                    break;

                  case 16:
                    yy.curr_lineno++;
                    break;

                  case 17:
                    yy.error_msg = "EOF in comment";
                    this.popState();
                    yy.lex_error();
                    break;

                  case 18:
                    ;
                    // skip whitespace
                    break;

                  case 19:
                    return "ELSE";
                    break;

                  case 20:
                    return "IF";
                    break;

                  case 21:
                    return "FI";
                    break;

                  case 22:
                    return "IN";
                    break;

                  case 23:
                    return "LET";
                    break;

                  case 24:
                    return "LOOP";
                    break;

                  case 25:
                    return "POOL";
                    break;

                  case 26:
                    return "THEN";
                    break;

                  case 27:
                    return "WHILE";
                    break;

                  case 28:
                    return "CASE";
                    break;

                  case 29:
                    return "ESAC";
                    break;

                  case 30:
                    return "OF";
                    break;

                  case 31:
                    return "NEW";
                    break;

                  case 32:
                    return "ISVOID";
                    break;

                  case 33:
                    return "NOT";
                    break;

                  case 34:
                    return "CLASS";
                    break;

                  case 35:
                    return "INHERITS";
                    break;

                  case 36:
                    return "TYPEID";
                    break;

                  case 37:
                    return "OBJECTID";
                    break;

                  case 38:
                    // "
                    // String constants (C syntax) Escape sequence \c is accepted for all characters c. Except for \n \t \b \f, the result is c.
                    string_error = false;
                    string_buf = "";
                    this.pushState("STRING");
                    break;

                  case 39:
                    // "
                    this.popState();
                    if (!string_error) {
                        if (string_buf.length >= MAX_STR_CONST) {
                            yy.error_msg = "String constant too long";
                            string_error = true;
                            yy.lex_error();
                            // error recovery
                            string_buf.length = MAX_STR_CONST;
                        }
                        return "STR_CONST";
                    }
                    break;

                  case 40:
                    // support both win and unix style of line endings
                    string_buf += "\n";
                    yy.curr_lineno++;
                    break;

                  case 41:
                    string_buf += "\t";
                    break;

                  case 42:
                    string_buf += "\n";
                    break;

                  case 43:
                    string_buf += "\b";
                    break;

                  case 44:
                    string_buf += "\f";
                    break;

                  case 45:
                    this.popState();
                    if (!string_error) {
                        this.error_msg = "Unterminated string constant";
                        return "ERROR";
                    }
                    break;

                  case 46:
                    if (!string_error) {
                        yy.error_msg = "String contains null character";
                        string_error = true;
                        yy.lex_error();
                    }
                    break;

                  case 47:
                    string_buf += yy_.yytext;
                    break;

                  case 48:
                    //"
                    string_buf += yy_.yytext;
                    break;

                  case 49:
                    // octal escape sequence
                    var result = parseInt(yy_.yytext, 8);
                    if (result > 255) {
                        if (!string_error) {
                            yy.error_msg = "Escape code is out of bounds";
                            string_error = true;
                            yy.lex_error();
                        }
                    }
                    string_buf += String.fromCharCode(result);
                    break;

                  case 50:
                    // like '\48' or '\0777777'
                    if (!string_error) {
                        yy.error_msg = "Invalid escaped character";
                        string_error = true;
                        yy.lex_error();
                    }
                    break;

                  case 51:
                    this.popState();
                    if (!string_error) {
                        yy.error_msg = "EOF in string";
                        yy.lex_error();
                    }
                    break;

                  case 52:
                    return yy_.yytext;
                    break;

                  case 53:
                    yy.error_msg = "Null character in code: ";
                    yy.lex_error();
                    break;

                  case 54:
                    yy.error_msg = "Skipping token: " + yy_.yytext;
                    yy.lex_error();
                    // simply skip error tokens
                    break;

                  case 55:
                    console.log(yy_.yytext);
                    break;
                }
            },
            rules: [ /^(?:=>)/, /^(?:<=)/, /^(?:<-)/, /^(?:(([0-9])*\.?([0-9])+|([0-9])+\.))/, /^(?:t[rR][uU][eE])/, /^(?:f[aA][lL][sS][eE])/, /^(?:\n)/, /^(?:--)/, /^(?:.*)/, /^(?:[\n])/, /^(?:$)/, /^(?:\*\))/, /^(?:\(\*)/, /^(?:\(\*)/, /^(?:\*\))/, /^(?:([^(*\n]+)|.)/, /^(?:[\n])/, /^(?:$)/, /^(?:[ \t\f\r\v]+)/, /^(?:else)/, /^(?:if)/, /^(?:fi)/, /^(?:in)/, /^(?:let)/, /^(?:loop)/, /^(?:pool)/, /^(?:then)/, /^(?:while)/, /^(?:case)/, /^(?:esac)/, /^(?:of)/, /^(?:new)/, /^(?:isvoid)/, /^(?:not)/, /^(?:class)/, /^(?:inherits)/, /^(?:([A-Z][_a-zA-Z0-9]*))/, /^(?:([a-z][_a-zA-Z0-9]*))/, /^(?:")/, /^(?:")/, /^(?:\\\n|\\\r\n)/, /^(?:\\t)/, /^(?:\\n)/, /^(?:\\b)/, /^(?:\\f)/, /^(?:\n)/, /^(?:\0|\\\0)/, /^(?:\\[^\0])/, /^(?:[^\0\\\n\"]+)/, /^(?:\\[0-7]{1,3})/, /^(?:\\[0-9]+)/, /^(?:$)/, /^(?:\+|\/|-|\*|=|<|\.|~|,|;|:|\(|\)|@|\{|\})/, /^(?:\0)/, /^(?:.)/, /^(?:.)/ ],
            conditions: {
                INHERITSDEF: {
                    rules: [],
                    inclusive: false
                },
                CLASSDEF: {
                    rules: [],
                    inclusive: false
                },
                STRING: {
                    rules: [ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 ],
                    inclusive: false
                },
                LINE_COMMENT: {
                    rules: [ 8, 9, 10 ],
                    inclusive: false
                },
                COMMENT: {
                    rules: [ 13, 14, 15, 16, 17 ],
                    inclusive: false
                },
                INITIAL: {
                    rules: [ 0, 1, 2, 3, 4, 5, 6, 7, 11, 12, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 52, 53, 54, 55 ],
                    inclusive: true
                }
            }
        };
        return lexer;
    }();
    parser.lexer = lexer;
    function Parser() {
        this.yy = {};
    }
    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
}();

if (typeof require !== "undefined" && typeof exports !== "undefined") {
    exports.parser = cool;
    exports.Parser = cool.Parser;
    exports.parse = function() {
        return cool.parse.apply(cool, arguments);
    };
    exports.main = function commonjsMain(args) {
        if (!args[1]) {
            console.log("Usage: " + args[0] + " FILE");
            process.exit(1);
        }
        var source = require("fs").readFileSync(require("path").normalize(args[1]), "utf8");
        return exports.parser.parse(source);
    };
    if (typeof module !== "undefined" && require.main === module) {
        exports.main(process.argv.slice(1));
    }
}
