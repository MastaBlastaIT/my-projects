"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Lint = require("tslint");
var tsutils = require("tsutils");
var tsquery_1 = require("@phenomnomnominal/tsquery");
var defaultNamesRegExp = /^(canActivate|canActivateChild|canDeactivate|canLoad|intercept|resolve|validate)$/;
var defaultTypesRegExp = /^EventEmitter$/;
var Rule = (function (_super) {
    tslib_1.__extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        return this.applyWithWalker(new Walker(sourceFile, this.getOptions(), program));
    };
    Rule.metadata = {
        description: "Enforces the use of a `just` alias for `of`.",
        options: null,
        optionsDescription: "Not configurable.",
        requiresTypeInfo: true,
        ruleName: "rxjs-just",
        type: "style",
        typescriptOnly: true
    };
    Rule.FAILURE_STRING = "Use just alias";
    return Rule;
}(Lint.Rules.TypedRule));
exports.Rule = Rule;
var Walker = (function (_super) {
    tslib_1.__extends(Walker, _super);
    function Walker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Walker.prototype.walk = function (sourceFile) {
        var _this = this;
        var typeChecker = this.getTypeChecker();
        var importIdentifier = undefined;
        var importDeclarations = tsquery_1.tsquery(sourceFile, "ImportDeclaration:has(StringLiteral[value=\"rxjs\"]),ImportDeclaration:has(StringLiteral[value=\"rxjs/observable/of\"])");
        importDeclarations.forEach(function (importDeclaration) {
            var importSpecifiers = tsquery_1.tsquery(importDeclaration, "ImportSpecifier:has(Identifier[escapedText=\"of\"])");
            importSpecifiers.forEach(function (importSpecifier) {
                if (tsutils.isImportSpecifier(importSpecifier)) {
                    if (!importSpecifier.propertyName && (importSpecifier.name.getText() === "of")) {
                        importIdentifier = importSpecifier.name;
                        var fix = Lint.Replacement.replaceFromTo(importIdentifier.getStart(), importIdentifier.getStart() + importIdentifier.getWidth(), "of as just");
                        _this.addFailureAtNode(importIdentifier, Rule.FAILURE_STRING, fix);
                    }
                }
            });
        });
        if (importIdentifier) {
            var callExpressions = tsquery_1.tsquery(sourceFile, "CallExpression:has(Identifier[escapedText=\"of\"])");
            callExpressions.forEach(function (callExpression) {
                if (tsutils.isCallExpression(callExpression)) {
                    var expression = callExpression.expression;
                    if (tsutils.isIdentifier(expression)) {
                        var symbol = typeChecker.getSymbolAtLocation(expression);
                        if (symbol) {
                            var declaration = symbol.getDeclarations()[0];
                            if (declaration === importIdentifier.parent) {
                                var fix = Lint.Replacement.replaceFromTo(expression.getStart(), expression.getStart() + expression.getWidth(), "just");
                                _this.addFailureAtNode(expression, Rule.FAILURE_STRING, fix);
                            }
                        }
                    }
                }
            });
        }
    };
    return Walker;
}(Lint.ProgramAwareRuleWalker));
